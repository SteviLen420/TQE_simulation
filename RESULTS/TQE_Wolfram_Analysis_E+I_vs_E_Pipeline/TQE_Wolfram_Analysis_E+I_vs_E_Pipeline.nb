(* SPDX-License-Identifier: MIT *)
(* Copyright (c) 2025 Stefan Len *)

(* =================================================================================== *)
(* TQE_Wolfram_Analysis_Clean_Pipeline.nb                                            *)
(* Author: Stefan Len                                                                *)
(* =================================================================================== *)

ClearAll["Global`*"];

(* ============================= *)
(* 1) DEFINE LOCAL DIRECTORIES   *)
(* ============================= *)

(* Base directory on Desktop *)
baseDir = FileNameJoin[{$HomeDirectory, "Desktop", "TQE_EI_SIMULATION_COLAB_GPU"}];

(* Check if base directory exists *)
If[!DirectoryQ[baseDir], 
  Print["Error: The specified 'baseDir' does not exist: ", baseDir]; 
  Abort[]
];

(* Automatically search for all subdirectories *)
dirs = FileNames["TQE_Universe_Simulation*", baseDir];

(* Separate into E+I vs. Energy-only based on folder name *)
dirsA = Select[dirs, StringContainsQ[#, "_EI_"] &];
dirsB = Select[dirs, StringContainsQ[#, "energy_only"] &];

(* Collect all CSV files recursively *)
filesA = Flatten[FileNames["*.csv", #, Infinity] & /@ dirsA];
filesB = Flatten[FileNames["*.csv", #, Infinity] & /@ dirsB];

Print["ðŸ“‚ Total E+I files: ", Length[filesA]];
Print["ðŸ“‚ Total E-only files: ", Length[filesB]];

(* ============================= *)
(* 2) HELPER FUNCTIONS           *)
(* ============================= *)

ClearAll[say, safeImport, toDS, tryCols, sanitizeForJSON];

say[txt_] := Print[Style[txt, 14, Bold, RGBColor[0.1, 0.2, 0.6]]];

(* Safely import a file, return an empty Dataset on failure *)
safeImport[f_] := Quiet @ Check[Import[f, "Dataset"], Dataset[<||>]];

(* Convert to Dataset if not already *)
toDS[x_] := If[Head[x] === Dataset, x, Dataset[x]];

(* Robustly select the first existing column from a list of possible names *)
tryCols[ds_, names_List] := Module[{firstRow, hit},
  If[Length[ds] == 0, Return[Missing["NotAvailable"]]];
  firstRow = Normal@First@ds;
  hit = SelectFirst[names, KeyExistsQ[firstRow, #] &, None];
  If[hit === None, Missing["NotAvailable"], ds[All, hit]]
];

(* Convert Missing[] to Null for JSON export *)
sanitizeForJSON[expr_] := expr /. {
   Missing[_] -> Null,
   ds_Dataset :> Normal[ds],
   Quantity[val_, _] :> val
};

(* Build associations for quick access *)
assocA = AssociationMap[safeImport, filesA];
assocB = AssociationMap[safeImport, filesB];

keysA = FileBaseName /@ Keys[assocA];
keysB = FileBaseName /@ Keys[assocB];

(* ============================= *)
(* 3) STABILITY + LOCK-IN        *)
(* ============================= *)

say["1) Stability + Lock-in"];

(* FIX: Added missing file gathering and dataset creation for stability metrics *)
stabAFiles = Select[Keys@assocA, StringContainsQ[#, "stability_cls", IgnoreCase -> True] &];
lockAFiles = Select[Keys@assocA, StringContainsQ[#, "lock_epoch", IgnoreCase -> True] &];

stabBFiles = Select[Keys@assocB, StringContainsQ[#, "stability_cls", IgnoreCase -> True] &];
lockBFiles = Select[Keys@assocB, StringContainsQ[#, "lock_epoch", IgnoreCase -> True] &];

stabA = Dataset @ Flatten[Normal /@ (assocA /@ stabAFiles), 1];
lockA = Dataset @ Flatten[Normal /@ (assocA /@ lockAFiles), 1];

stabB = Dataset @ Flatten[Normal /@ (assocB /@ stabBFiles), 1];
lockB = Dataset @ Flatten[Normal /@ (assocB /@ lockBFiles), 1];


stabilitySummary[ds_] := Module[
  {stableCol, lockCol, n, nStable, nLock},
  
  n = Length[ds];
  If[n == 0, 
    Return@<|"n" -> 0, "stable_n" -> Missing["NA"], "lockin_n" -> Missing["NA"]|>
  ];
  
  stableCol = tryCols[ds, {"stability_cls","stable","is_stable","stable_flag","stability"}];
  nStable = If[MissingQ[stableCol], 
    Missing["NA"],
    Total@Boole[DeleteMissing@Normal@stableCol == 1]
  ];
  
  lockCol   = tryCols[ds, {"lock_epoch","lockin_epoch","lock_step","lockin_step","lock"}];
  nLock = If[MissingQ[lockCol], 
    Missing["NA"],
    Count[DeleteMissing@Normal@lockCol, _?NumericQ]
  ];
  
  <|"n" -> n, "stable_n" -> nStable, "lockin_n" -> nLock|>
];

stabResA = stabilitySummary[stabA];
stabResB = stabilitySummary[stabB];

Grid[{
  {"Metric", "E+I", "E-only"},
  {"Total Universes", stabResA["n"], stabResB["n"]},
  {"Stable Count", stabResA["stable_n"], stabResB["n"]},
  {"Lock-in Count", stabResA["lockin_n"], stabResB["lockin_n"]}
}, Frame -> All]


(* ============================= *)
(* 4) CMB COLD-SPOTS             *)
(* ============================= *)

say["2) CMB cold-spots"];

coldAFiles = Select[Keys@assocA, StringContainsQ[#, "coldspot", IgnoreCase -> True] &];
coldBFiles = Select[Keys@assocB, StringContainsQ[#, "coldspot", IgnoreCase -> True] &];

(* FIX: The 'coldBFiles' and 'aoeBFiles' lists had to be used with 'assocB', not by themselves *)
coldA = Dataset @ Flatten[Normal /@ (toDS /@ (assocA /@ coldAFiles)), 1];
coldB = Dataset @ Flatten[Normal /@ (toDS /@ (assocB /@ coldBFiles)), 1];


coldStats[ds_] := Module[{v},
  If[Length[ds] == 0, 
    Return@<|"count" -> 0, "min" -> Missing["NA"], "mean" -> Missing["NA"], "median" -> Missing["NA"], "below_-70" -> Missing["NA"]|>
  ];
  
  v = DeleteMissing@Normal@tryCols[ds, {"z_value", "depth_uK"}];
  
  (* FIX: Handle the case where 'v' is an empty list after processing *)
  If[Length[v] == 0,
    Return@<|"count" -> 0, "min" -> Missing["NA"], "mean" -> Missing["NA"], "median" -> Missing["NA"], "below_-70" -> 0|>
  ];
  
  <|
    "count" -> Length[v],
    "min" -> Min[v],
    "mean" -> Mean[v],
    "median" -> Median[v],
    "below_-70" -> Count[v, x_ /; x <= -70]
  |>
];


coldResA = coldStats[coldA];
coldResB = coldStats[coldB];

Grid[{
  {"Metric", "E+I", "E-only"},
  {"Total Spots", coldResA["count"], coldResB["count"]},
  {"Deepest Spot", coldResA["min"], coldResB["min"]},
  {"Average Depth", coldResA["mean"], coldResB["mean"]},
  {"Median Depth", coldResA["median"], coldResB["median"]},
  {"Count â‰¤ -70 ÂµK", coldResA["below_-70"], coldResB["below_-70"]}
}, Frame -> All]


(* ============================= *)
(* 5) AOE (Angle of Emergence)   *)
(* ============================= *)

say["3) AOE metrics"];

aoeAFiles = Select[Keys@assocA, StringContainsQ[#, "aoe", IgnoreCase -> True] &];
aoeBFiles = Select[Keys@assocB, StringContainsQ[#, "aoe", IgnoreCase -> True] &];

aoeA = Dataset @ Flatten[Normal /@ (toDS /@ (assocA /@ aoeAFiles)), 1];
aoeB = Dataset @ Flatten[Normal /@ (toDS /@ (assocB /@ aoeBFiles)), 1]; (* This was also fixed here *)

aoeSummary[ds_] := Module[{vals},
  If[Length[ds] == 0, Return@<|"count" -> 0, "mean" -> Missing["NA"]|>];
  
  vals = DeleteMissing @ Normal @ tryCols[ds, 
     {"aoe", "aoe_value", "align", "cls", "reg", "metric", "value"}];
  
  If[Length[vals] == 0,
    <|"count" -> Length[ds], "mean" -> Missing["NA"]|>,
    <|"count" -> Length[ds], "mean" -> Mean[vals]|>
  ]
];

aoeResA = aoeSummary[aoeA];
aoeResB = aoeSummary[aoeB];

Grid[{
  {"Metric", "E+I", "E-only"},
  {"Total AOE rows", aoeResA["count"], aoeResB["count"]},
  {"Mean Value", aoeResA["mean"], aoeResB["mean"]}
}, Frame -> All]


(* ============================= *)
(* 6) FINE-TUNING METRICS        *)
(* ============================= *)

say["4) Fine-tuning metrics"];

ftAFiles = Select[Keys@assocA, StringContainsQ[#, "finetune", IgnoreCase -> True] &];
ftBFiles = Select[Keys@assocB, StringContainsQ[#, "finetune", IgnoreCase -> True] &];

ftA = Dataset @ Flatten[Normal /@ (assocA /@ ftAFiles), 1];
ftB = Dataset @ Flatten[Normal /@ (assocB /@ ftBFiles), 1];

bestACC[ds_] := Max@DeleteMissing@Normal@tryCols[ds, {"acc","finetune_acc_delta"}];
bestAUC[ds_] := Max@DeleteMissing@Normal@tryCols[ds, {"auc","finetune_auc_delta"}];

ftResA = <|"best_acc" -> bestACC[ftA], "best_auc" -> bestAUC[ftA]|>;
ftResB = <|"best_acc" -> bestACC[ftB], "best_auc" -> bestAUC[ftB]|>;

summFT[ds_] := Module[{acc, auc},
  If[Length[ds] == 0, 
    Return@<|"best_acc" -> Missing["NA"], "best_auc" -> Missing["NA"]|>
  ];
  
  acc = tryCols[ds, {"acc","accuracy","val_acc","acc_delta"}];
  auc = tryCols[ds, {"auc","roc_auc","val_auc","auc_delta"}];
  
  <|
    "best_acc" -> If[MissingQ[acc], Missing["NA"], Max@DeleteMissing@Normal@acc],
    "best_auc" -> If[MissingQ[auc], Missing["NA"], Max@DeleteMissing@Normal@auc]
  |>
];

ftResA = summFT[ftA];
ftResB = summFT[ftB];

Grid[{
  {"Metric", "E+I", "E-only"},
  {"Best ACC", ftResA["best_acc"], ftResB["best_acc"]},
  {"Best AUC", ftResA["best_auc"], ftResB["best_auc"]}
}, Frame -> All]


(* ============================= *)
(* 7) SAVE RESULTS               *)
(* ============================= *)

say["Saving results to disk"];

timestamp = DateString[{"Year", "Month", "Day", "Hour", "Minute", "Second"}];

(* Save directly to Desktop, not inside baseDir *)
desktopDir = FileNameJoin[{$HomeDirectory, "Desktop"}];
outDir = FileNameJoin[{desktopDir, "TQE_Wolfram_Clean_Output_" <> timestamp}];

If[!DirectoryQ[outDir], CreateDirectory[outDir, CreateIntermediateDirectories -> True]];

(* Sanitize + export *)
Export[FileNameJoin[{outDir, "stability.json"}],
  sanitizeForJSON@<|"E+I" -> stabResA, "E-only" -> stabResB|>
];
Export[FileNameJoin[{outDir, "cmb_coldspots.json"}],
  sanitizeForJSON@<|"E+I" -> coldResA, "E-only" -> coldResB|>
];
Export[FileNameJoin[{outDir, "aoe.json"}],
  sanitizeForJSON@<|"E+I" -> aoeResA, "E-only" -> aoeResB|>
];
Export[FileNameJoin[{outDir, "finetune.json"}],
  sanitizeForJSON@<|"E+I" -> ftResA, "E-only" -> ftResB|>
];

say["âœ… Results exported to: " <> outDir];
