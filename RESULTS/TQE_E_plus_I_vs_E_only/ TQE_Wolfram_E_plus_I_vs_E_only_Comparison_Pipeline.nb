(* SPDX-License-Identifier: MIT *)
(* Copyright (c) 2025 Stefan Len *)

(* ================================================================== *)
(*  TQE_Wolfram_E_plus_I_vs_E_only_Comparison_Pipeline.nb             *)
(*  Author: Stefan Len                                                *)
(* ================================================================== *)
(*  Notes: This is ONLY the header adapted for the E+I vs E-only code.*)
(*         Add your actual analysis implementation below this block.  *)

(* ========= User inputs (root folders) ========= *)
rootEI   = "/Users/stevilen/Desktop/TQE_E_plus_I_vs_E_only/TQE_E_plus_I_Simulation";
rootEonly= "/Users/stevilen/Desktop/TQE_E_plus_I_vs_E_only/TQE_E_Only_Simulation";

(* ========= Helpers ========= *)

(* Safe dataset import from CSV; empty Dataset on error *)
safeImportDataset[f_] := Quiet @ Check[Import[f, "Dataset"], Dataset[{}]];

(* List the first few CSVs we see under a root (for debugging) *)
listCSVs[root_] := Module[{all},
  all = Join[
    FileNames["*.csv", root, Infinity],
    FileNames["*.CSV", root, Infinity]
  ];
  Print["ðŸ“„ CSVs under ", root, ": ", Length[all]];
  Print /@ Take[all, UpTo[10]]; (* show first up to 10 *)
  all
];

(* Search recursively for the first existing file that matches any of the patterns *)
findFirstFile[root_, patterns_List] := Module[{all},
  all = listCSVs[root];  (* debug listing + gather both csv/CSV *)
  SelectFirst[
    all,
    Function[f, AnyTrue[patterns, StringContainsQ[FileNameTake[f], #, IgnoreCase -> True] &]],
    Missing["NotFound"]
  ]
];

(* Safe numeric pretty-print *)
safeNum[x_] := Which[
  NumericQ[x], ToString @ NumberForm[N@x, {6, 4}],
  True,       "NA"
];

(* Aggregate a few canonical metrics from a dataset if the columns exist *)
summarizeRun[ds_] := Module[
  {
    take = Association[],
    has = Function[c, MemberQ[Keys[Normal@First@ds], c]]
  },
  If[Length[ds]==0, Return[<||>]];

  (* Core ratios/flags *)
  If[has["stable"],    take["stable_ratio"]    = N@Mean[Normal@ds[All, "stable"]]];
  If[has["lockin"],    take["lockin_ratio"]    = N@Mean[Normal@ds[All, "lockin"]]];
  If[has["stable_epoch"], take["stable_epoch_mean"] = N@Mean[Normal@ds[All, "stable_epoch"]];
                           take["stable_epoch_std"]  = N@StandardDeviation[Normal@ds[All, "stable_epoch"]]];
  If[has["lock_epoch"],   take["lock_epoch_mean"]   = N@Mean[Normal@ds[All, "lock_epoch"]];
                           take["lock_epoch_std"]    = N@StandardDeviation[Normal@ds[All, "lock_epoch"]]];

  (* Energy/Information composites if present *)
  If[has["E"],  take["E_mean"]  = N@Mean[Normal@ds[All, "E"]];
                take["E_std"]   = N@StandardDeviation[Normal@ds[All, "E"]]];
  If[has["I"],  take["I_mean"]  = N@Mean[Normal@ds[All, "I"]];
                take["I_std"]   = N@StandardDeviation[Normal@ds[All, "I"]]];
  If[has["X"],  take["X_mean"]  = N@Mean[Normal@ds[All, "X"]];
                take["X_std"]   = N@StandardDeviation[Normal@ds[All, "X"]]];

  (* Sample size *)
  take["N_rows"] = Length[ds];

  take
];

(* Try to load the most informative table for a run *)
loadBestRunTable[root_] := Module[{f},
  f = findFirstFile[root, {"metrics_joined", "metrics-joined", "joined", "math_check_results"}];
  If[MissingQ[f],
    f = findFirstFile[root, {"tqe_runs", "tqe-runs", "runs"}];
  ];
  If[MissingQ[f],
    <|"status"->"not_found", "file"->None, "data"->Dataset[{}]|>,
    <|"status"->"ok", "file"->f, "data"->safeImportDataset[f]|>
  ]
];

(* ========= Load data for both variants ========= *)

ei   = loadBestRunTable[rootEI];
eonly= loadBestRunTable[rootEonly];

(* ========= Summaries ========= *)

sumEI    = summarizeRun[ei["data"]];
sumEonly = summarizeRun[eonly["data"]];

(* Align keys and build comparison rows *)
allKeys = Union[Keys[sumEI], Keys[sumEonly]];
comparison = Dataset @ Table[
  <|
    "metric"   -> k,
    "E+I"      -> Lookup[sumEI, k, Missing["NA"]],
    "E-only"   -> Lookup[sumEonly, k, Missing["NA"]],
    "diff(E+I - E-only)" -> Quiet@Check[Lookup[sumEI,k,Missing["NA"]] - Lookup[sumEonly,k,Missing["NA"]], Missing["NA"]]
  |>,
  {k, allKeys}
];

(* ==== Show results inline in the notebook ==== *)
Print["E+I source: ", ei["file"]];
Print["E-only source: ", eonly["file"]];

(* Show per-run summaries side-by-side *)
summaryKeys = Union[Keys[sumEI], Keys[sumEonly]];
summaryInline = Dataset @ Table[
  <|
    "metric" -> k,
    "E+I"    -> Lookup[sumEI, k, Missing["NA"]],
    "E-only" -> Lookup[sumEonly, k, Missing["NA"]]
  |>,
  {k, summaryKeys}
];

summaryInline

(* Show full comparison table (already a Dataset) *)
comparison

(* ========= Output paths ========= *)

timestamp = DateString[{"Year","Month","Day","Hour","Minute","Second"}];
outRoot   = FileNameJoin[{$HomeDirectory, "Desktop", "TQE_E_plus_I_vs_E_only_"<>timestamp}];
If[!DirectoryQ[outRoot], CreateDirectory[outRoot]];

outCSV  = FileNameJoin[{outRoot, "comparison_summary.csv"}];
outJSON = FileNameJoin[{outRoot, "comparison_summary.json"}];

(* ========= Save CSV & JSON ========= *)

Export[outCSV, Normal@comparison];

Export[
  outJSON,
  (Association[
     "files" -> <|
        "E+I_source"    -> ei["file"],
        "E-only_source" -> eonly["file"]
     |>,
     "summary" -> Association[
        "E+I"    -> sumEI,
        "E-only" -> sumEonly
     ],
     "comparison_rows" -> Normal@comparison
   ] /. {None -> Null, Missing[_] -> Null}),
  "JSON"
];

Print["âœ… Saved: ", outCSV];
Print["âœ… Saved: ", outJSON];
