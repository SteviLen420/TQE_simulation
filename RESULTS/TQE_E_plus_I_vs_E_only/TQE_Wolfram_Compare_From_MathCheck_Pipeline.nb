(* SPDX-License-Identifier: MIT *)
(* Copyright (c) 2025 Stefan Len *)

(* ================================================================== *)
(*  TQE_Wolfram_Compare_From_MathCheck_Pipeline.nb                    *)
(*  Author: Stefan Len                                                *)
(* ================================================================== *)
(*  Notes: Compares E+I vs E-only based on CSV tables.                *)

(* ========= User inputs (root folders) ========= *)
rootEI    = "/Users/stevilen/Desktop/TQE_E_plus_I_vs_E_only/TQE_E_plus_I_Simulation";
rootEonly = "/Users/stevilen/Desktop/TQE_E_plus_I_vs_E_only/TQE_E_Only_Simulation";

(* ========= Helpers ========= *)

(* Safe dataset import from CSV; returns empty Dataset on error *)
safeImportDataset[f_] := Quiet @ Check[Import[f, "Dataset"], Dataset[{}]];

(* List CSV files under a root (debugging aid) *)
listCSVs[root_] := Module[{all},
  all = Join[
    FileNames["*.csv", root, Infinity],
    FileNames["*.CSV", root, Infinity]
  ];
  Print["ðŸ“„ CSVs under ", root, ": ", Length[all]];
  Print /@ Take[all, UpTo[10]];  (* show up to the first 10 paths *)
  all
];

(* Find newest math_check_results CSV under a root. Silent, no debug spam. *)
findNewestMathCheck[root_, variant_] := Module[{all, keep, newest},
  (* variant is "EI" or "Eonly" selector via filename signature *)
  all = Join[
    FileNames["*.csv", root, Infinity],
    FileNames["*.CSV", root, Infinity]
  ];
  keep = Select[all,
    If[variant === "EI",
      StringContainsQ[FileNameTake[#], "math_check_results_EI", IgnoreCase -> True]&,
      StringContainsQ[FileNameTake[#], "math_check_results_energy_only", IgnoreCase -> True]&
    ]
  ];
  newest = If[keep === {}, Missing["NotFound"],
    First @ Reverse @ SortBy[keep, FileDate]   (* newest by mtime *)
  ];
  newest
];

(* Pretty-print numeric; otherwise NA *)
safeNum[x_] := Which[
  NumericQ[x], ToString @ NumberForm[N@x, {6, 4}],
  True,       "NA"
];

(* Summarize from math_check_results Dataset by taking the row File=="metrics_joined_*" *)
summarizeFromMathCheck[ds_, which_] := Module[
  {row, cols, getMean},
  (* which is "EI" or "E-Only" tag to match inside the File field *)
  row = SelectFirst[Normal@ds,
          StringContainsQ[ToString@Lookup[#, "File", ""], 
            If[which === "EI", "metrics_joined_EI", "metrics_joined_E-Only"], 
            IgnoreCase -> True
          ]&
        ,
        Missing["NotFound"]
        ];
  If[MissingQ[row],
    <||>, (* nothing found *)
    cols = Lookup[row, "Columns", <||>];       (* nested association *)
    getMean[name_] := Lookup[Lookup[cols, name, <||>], "Mean", Missing["NA"]];
    <|
      "stable_ratio"       -> getMean["stable"],
      "lockin_ratio"       -> getMean["lockin"],
      "stable_epoch_mean"  -> getMean["stable_epoch"],
      "lock_epoch_mean"    -> getMean["lock_epoch"],
      "E_mean"             -> getMean["E"],
      "I_mean"             -> getMean["I"],
      "X_mean"             -> getMean["X"],
      "N_rows"             -> Lookup[row, "TotalRows", Missing["NA"]]
    |>
  ]
];

  (* Core ratios/flags *)
  If[has["stable"],        take["stable_ratio"]       = N @ Mean[Normal @ ds[All, "stable"]]];
  If[has["lockin"],        take["lockin_ratio"]       = N @ Mean[Normal @ ds[All, "lockin"]]];
  If[has["stable_epoch"],
    take["stable_epoch_mean"] = N @ Mean[Normal @ ds[All, "stable_epoch"]];
    take["stable_epoch_std"]  = N @ StandardDeviation[Normal @ ds[All, "stable_epoch"]];
  ];
  If[has["lock_epoch"],
    take["lock_epoch_mean"]   = N @ Mean[Normal @ ds[All, "lock_epoch"]];
    take["lock_epoch_std"]    = N @ StandardDeviation[Normal @ ds[All, "lock_epoch"]];
  ];

  (* Energy/Information composites if present *)
  If[has["E"],
    take["E_mean"] = N @ Mean[Normal @ ds[All, "E"]];
    take["E_std"]  = N @ StandardDeviation[Normal @ ds[All, "E"]];
  ];
  If[has["I"],
    take["I_mean"] = N @ Mean[Normal @ ds[All, "I"]];
    take["I_std"]  = N @ StandardDeviation[Normal @ ds[All, "I"]];
  ];
  If[has["X"],
    take["X_mean"] = N @ Mean[Normal @ ds[All, "X"]];
    take["X_std"]  = N @ StandardDeviation[Normal @ ds[All, "X"]];
  ];

  (* Sample size *)
  take["N_rows"] = Length[ds];

  take
];

(* Load math_check_results CSV for the given variant ("EI" / "Eonly") *)
loadMathCheck[root_, variant_] := Module[{f},
  f = findNewestMathCheck[root, variant];
  If[MissingQ[f],
    <|"status"->"not_found", "file"->None, "data"->Dataset[{}]|>,
    <|"status"->"ok", "file"->f, "data"->safeImportDataset[f]|>
  ]
];

  (* 2) Else fall back to tqe_runs*.csv *)
  f = findFirstFile[root, {"tqe_runs", "tqe-runs", "runs"}];
  If[!MissingQ[f],
    Return[<|"status" -> "ok", "file" -> f, "data" -> safeImportDataset[f]|>];
  ];

  <|"status" -> "not_found", "file" -> None, "data" -> Dataset[{}]|>
];

(* ========= Load data for both variants ========= *)

ei    = loadMathCheck[rootEI, "EI"];
eonly = loadMathCheck[rootEonly, "Eonly"];

(* ========= Summaries ========= *)

sumEI    = summarizeFromMathCheck[ei["data"], "EI"];
sumEonly = summarizeFromMathCheck[eonly["data"], "E-Only"];

(* Align keys and build comparison rows *)
allKeys = Union[Keys[sumEI], Keys[sumEonly]];
comparison = Dataset @ Table[
  <|
    "metric"                -> k,
    "E+I"                   -> Lookup[sumEI, k, Missing["NA"]],
    "E-only"                -> Lookup[sumEonly, k, Missing["NA"]],
    "diff(E+I - E-only)"    -> Quiet @ Check[
      Lookup[sumEI, k, Missing["NA"]] - Lookup[sumEonly, k, Missing["NA"]],
      Missing["NA"]
    ]
  |>,
  {k, allKeys}
];

(* ==== Show results inline in the notebook ==== *)
Print["E+I source: ", ei["file"]];
Print["E-only source: ", eonly["file"]];

(* Side-by-side per-run summaries *)
summaryKeys   = Union[Keys[sumEI], Keys[sumEonly]];
summaryInline = Dataset @ Table[
  <|
    "metric" -> k,
    "E+I"    -> Lookup[sumEI, k, Missing["NA"]],
    "E-only" -> Lookup[sumEonly, k, Missing["NA"]]
  |>,
  {k, summaryKeys}
];

summaryInline

(* Full comparison table *)
comparison

(* ========= Output paths ========= *)

timestamp = DateString[{"Year","Month","Day","Hour","Minute","Second"}];
outRoot   = FileNameJoin[{$HomeDirectory, "Desktop", "TQE_E_plus_I_vs_E_only_" <> timestamp}];
If[!DirectoryQ[outRoot], CreateDirectory[outRoot]];

outCSV  = FileNameJoin[{outRoot, "comparison_summary.csv"}];
outJSON = FileNameJoin[{outRoot, "comparison_summary.json"}];

(* ========= Save CSV & JSON ========= *)

Export[outCSV, Normal @ comparison];

Export[
  outJSON,
  (Association[
     "files" -> <|
       "E+I_source"    -> ei["file"],
       "E-only_source" -> eonly["file"]
     |>,
     "summary" -> Association[
       "E+I"    -> sumEI,
       "E-only" -> sumEonly
     ],
     "comparison_rows" -> Normal @ comparison
   ] /. {None -> Null, Missing[_] -> Null}),
  "JSON"
];

Print["âœ… Saved: ", outCSV];
Print["âœ… Saved: ", outJSON];
